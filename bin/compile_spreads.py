#!/usr/bin/env python3
"""Compile assets/spreads/*.tsv into static/js/spreads.js.

Run from the project root:
    python3 bin/compile_spreads.py
"""

import csv
import glob
import os
import sys

BASE = os.path.join(os.path.dirname(__file__), '..')
SPREADS_DIR = os.path.join(BASE, 'assets', 'spreads')
OUTPUT = os.path.join(BASE, 'static', 'js', 'spreads.js')


def read_tsv(path):
    with open(path, newline='', encoding='utf-8') as f:
        reader = csv.DictReader(f, delimiter='\t')
        return list(reader)


def set_nested(d, keys, value):
    """Set d[keys[0]][keys[1]]...[keys[-1]] = value, creating dicts as needed."""
    for key in keys[:-1]:
        if key not in d:
            d[key] = {}
        d = d[key]
    d[keys[-1]] = value


def convert_arrays(obj):
    """Recursively convert dicts whose keys are all consecutive integers to lists."""
    if not isinstance(obj, dict):
        return obj
    converted = {k: convert_arrays(v) for k, v in obj.items()}
    try:
        indices = {int(k): v for k, v in converted.items()}
        if sorted(indices.keys()) == list(range(len(indices))):
            return [indices[i] for i in range(len(indices))]
    except (ValueError, TypeError):
        pass
    return converted


def js_string(s):
    s = s.replace('\\', '\\\\').replace("'", "\\'")
    return f"'{s}'"


def js_value(v, indent=0):
    pad = '    ' * indent
    if isinstance(v, bool):
        return 'true' if v else 'false'
    elif isinstance(v, int):
        return str(v)
    elif isinstance(v, str):
        return js_string(v)
    elif isinstance(v, list):
        items = [js_value(item, indent + 1) for item in v]
        short = '[' + ', '.join(items) + ']'
        if len(short) <= 80:
            return short
        inner = (',\n' + pad + '    ').join(items)
        return '[\n' + pad + '    ' + inner + '\n' + pad + ']'
    elif isinstance(v, dict):
        pairs = [f'{k}: {js_value(val, indent + 1)}' for k, val in v.items()]
        short = '{ ' + ', '.join(pairs) + ' }'
        if len(short) <= 60:
            return short
        inner = (',\n' + pad + '    ').join(pairs)
        return '{\n' + pad + '    ' + inner + '\n' + pad + '}'
    else:
        return repr(v)


def main():
    tsv_paths = sorted(glob.glob(os.path.join(SPREADS_DIR, '*.tsv')))
    if not tsv_paths:
        print(f'Error: no TSV files found in {SPREADS_DIR}', file=sys.stderr)
        sys.exit(1)

    spreads = {}
    spread_order = []

    for path in tsv_paths:
        rows = read_tsv(path)
        flat = {}
        for row in rows:
            key = row['key'].strip()
            value = row['value']
            parts = key.split('__')
            set_nested(flat, parts, value)
        data = convert_arrays(flat)

        # Coerce known scalar types
        if 'isDefault' in data:
            data['isDefault'] = data['isDefault'].strip().lower() == 'true'
        if 'count' in data:
            data['count'] = int(data['count'].strip())

        # TSV uses 'position' (singular); JS uses 'positions' (plural)
        if 'position' in data:
            data['positions'] = data.pop('position')

        spread_id = data.get('id', os.path.splitext(os.path.basename(path))[0])
        spreads[spread_id] = data
        spread_order.append(spread_id)

    out = []
    out.append('// Spread configurations — positions are { name } objects')
    out.append('// AUTO-GENERATED by bin/compile_spreads.py — edit assets/spreads/*.tsv instead')
    out.append('const SPREADS = {')
    for sid in spread_order:
        data = spreads[sid]
        out.append(f'    {sid}: {{')
        for k, v in data.items():
            out.append(f'        {k}: {js_value(v, 2)},')
        out.append('    },')
    out.append('};')
    out.append('')

    content = '\n'.join(out)
    with open(OUTPUT, 'w', encoding='utf-8') as f:
        f.write(content)

    print(f'✅ Generated static/js/spreads.js ({len(spread_order)} spreads)')


if __name__ == '__main__':
    main()
