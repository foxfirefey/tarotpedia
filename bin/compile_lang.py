#!/usr/bin/env python3
"""Compile lang/languages.tsv and lang/<label>.tsv into js/lang.js.

Run from the project root:
    python3 bin/compile_lang.py
"""

import csv
import os
import sys

BASE = os.path.join(os.path.dirname(__file__), '..')
LANG_DIR = os.path.join(BASE, 'assets', 'lang')
OUTPUT = os.path.join(BASE, 'static', 'js', 'lang.js')


def read_tsv(path):
    with open(path, newline='', encoding='utf-8') as f:
        reader = csv.DictReader(f, delimiter='\t')
        return list(reader)


def set_nested(d, keys, value):
    """Set d[keys[0]][keys[1]]...[keys[-1]] = value, creating dicts as needed."""
    for key in keys[:-1]:
        if key not in d:
            d[key] = {}
        d = d[key]
    d[keys[-1]] = value


def convert_arrays(obj):
    """Recursively convert dicts whose keys are all consecutive integers to lists."""
    if not isinstance(obj, dict):
        return obj
    converted = {k: convert_arrays(v) for k, v in obj.items()}
    try:
        indices = {int(k): v for k, v in converted.items()}
        if sorted(indices.keys()) == list(range(len(indices))):
            return [indices[i] for i in range(len(indices))]
    except (ValueError, TypeError):
        pass
    return converted


def js_string(s):
    s = s.replace('\\', '\\\\').replace("'", "\\'")
    return f"'{s}'"


def js_value(v, indent=0):
    pad = '    ' * indent
    if isinstance(v, str):
        return js_string(v)
    elif isinstance(v, list):
        items = [js_value(item, indent + 1) for item in v]
        short = '[' + ', '.join(items) + ']'
        if len(short) <= 80:
            return short
        inner = (',\n' + pad + '    ').join(items)
        return '[\n' + pad + '    ' + inner + '\n' + pad + ']'
    elif isinstance(v, dict):
        inner_lines = []
        for k, val in v.items():
            inner_lines.append(f'{pad}    {k}: {js_value(val, indent + 1)}')
        return '{\n' + ',\n'.join(inner_lines) + '\n' + pad + '}'
    else:
        return repr(v)


def main():
    languages_path = os.path.join(LANG_DIR, 'languages.tsv')
    if not os.path.exists(languages_path):
        print(f'Error: {languages_path} not found', file=sys.stderr)
        sys.exit(1)

    lang_rows = read_tsv(languages_path)
    languages = {}
    lang_order = []
    default_language = None

    for row in lang_rows:
        label = row['label'].strip()
        languages[label] = {
            'name': row['name'].strip(),
            'domain': row['domain'].strip(),
        }
        lang_order.append(label)
        if (row.get('default') or '').strip().upper() == 'YES':
            default_language = label

    if default_language is None:
        print('Error: no language has "YES" in the default column', file=sys.stderr)
        sys.exit(1)

    translations = {}
    for label in lang_order:
        tsv_path = os.path.join(LANG_DIR, f'{label}.tsv')
        if not os.path.exists(tsv_path):
            print(f'Error: {tsv_path} not found', file=sys.stderr)
            sys.exit(1)
        rows = read_tsv(tsv_path)
        flat = {}
        for row in rows:
            key = row['key'].strip()
            value = row['value']
            parts = key.split('__')
            set_nested(flat, parts, value)
        translations[label] = convert_arrays(flat)

    out = []
    out.append('// Language configuration — maps keys to Wikipedia subdomains')
    out.append('// AUTO-GENERATED by bin/compile_lang.py — edit lang/*.tsv instead')
    out.append('const LANGUAGES = {')
    for label in lang_order:
        info = languages[label]
        out.append(f"    {label}: {{ name: {js_string(info['name'])}, domain: {js_string(info['domain'])} }},")
    out.append('};')
    out.append('')
    out.append(f"const DEFAULT_LANGUAGE = '{default_language}';")
    out.append('')
    out.append('// UI translations — keyed by interface language')
    out.append('const TRANSLATIONS = {')
    for label in lang_order:
        trans = translations[label]
        out.append(f'    {label}: {{')
        for key, val in trans.items():
            out.append(f'        {key}: {js_value(val, 2)},')
        out.append('    },')
    out.append('};')
    out.append('')

    content = '\n'.join(out)
    with open(OUTPUT, 'w', encoding='utf-8') as f:
        f.write(content)

    print(f'✅ Generated js/lang.js ({len(lang_order)} languages)')


if __name__ == '__main__':
    main()
